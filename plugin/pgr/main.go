package pgr // Package pgr hosted by Phigros-Library
import (
	"encoding/json"
	"github.com/FloatTech/floatbox/binary"
	"github.com/FloatTech/floatbox/web"
	ctrl "github.com/FloatTech/zbpctrl"
	"github.com/FloatTech/zbputils/control"
	"github.com/FloatTech/zbputils/img/text"
	zero "github.com/wdvxdr1123/ZeroBot"
	"github.com/wdvxdr1123/ZeroBot/message"
	"strconv"
	"strings"
	"time"
)

// too lazy,so this way is to use thrift host server (Working on HiMoYo Cloud.) (replace: now use PUA API)

// update: use PhigrosUnlimitedAPI + Phigros Library as Maintainer.

var (
	engine = control.Register("pgr", &ctrl.Options[*zero.Ctx]{
		DisableOnDefault:  false,
		Help:              "Hi NekoPachi!\n",
		PrivateDataFolder: "phi",
	})
)

func init() {
	engine.OnRegex(`^\/pgr\sbind\s(.*)$`).SetBlock(true).Handle(func(ctx *zero.Ctx) {
		hash := ctx.State["regex_matched"].([]string)[1]
		userInfo := GetUserInfoFromDatabase(ctx.Event.UserID)
		if userInfo.Time+(12*60*60) > time.Now().Unix() {
			ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("12小时内仅允许绑定一次哦"))
			return
		}
		indexReply := DecHashToRaw(hash)
		if indexReply == "" {
			ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("请前往 https://pgr.impart.icu 获取绑定码进行绑定 "))
			return
		}
		// get session.
		getQQID, getSessionID := RawJsonParse(indexReply)
		if getQQID != ctx.Event.UserID {
			ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("请求Hash中QQ号不一致，请使用自己的号重新申请"))
			return
		}
		data, err := web.GetData("localhost:9090/saveUrl/" + getSessionID)
		if err != nil {
			ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("出现错误：", err))
			return
		}
		var PhigrosSaves saveURLData
		_ = json.Unmarshal(data, &PhigrosSaves)
		if PhigrosSaves.SaveUrl == "" {
			ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("出现错误：未找到此用户"))
			return
		}
		_ = FormatUserDataBase(getQQID, getSessionID, time.Now().Unix()).BindUserDataBase()
		ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("绑定成功～"))
	})
	engine.OnFullMatch("/pgr b19").SetBlock(true).Handle(func(ctx *zero.Ctx) {
		data := GetUserInfoFromDatabase(ctx.Event.UserID)
		getDataSession := data.PhiSession
		getUrlData, err := web.GetData("localhost:9090/saveUrl/" + getDataSession)
		if err != nil {
			ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("出现错误：", err))
			return
		}
		var PhigrosSaves saveURLData
		_ = json.Unmarshal(getUrlData, &PhigrosSaves)
		getB19Refer, err := web.GetData("localhost:9090/b19/" + PhigrosSaves.SaveUrl)
		if err != nil {
			ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("出现错误：", err))
			return
		}
		var PhigrosB19Data b19info
		_ = json.Unmarshal(getB19Refer, &PhigrosB19Data)
		getLength := len(PhigrosB19Data)
		// start Render
		/*
			Phigros B19 Beta | Rating(RKS) : 13.102 | 课题分 : 245
			1. DESTRUCTION321 - Normal1Zer vs BrokenBerdz
		*/
		var renderText string
		var isFC string
		header := "Phigros B19 Beta | Rating (RKS) : " + strconv.FormatFloat(PhigrosSaves.RKS, 'f', 2, 64) + " | 课题分 ： " + strconv.FormatInt(int64(PhigrosSaves.HardCoreScore), 10) + "\n"
		for i := 0; i < getLength; i++ {
			if PhigrosB19Data[i].Fc == true {
				isFC = "FC"
			} else {
				isFC = ""
			}
			getReplaceNameWithArtist := strings.ReplaceAll(PhigrosB19Data[i].SongId, ".", " - ")
			renderText += strconv.FormatInt(int64(i+1), 10) + ". " + getReplaceNameWithArtist + " ( " + PhigrosB19Data[i].Level + " )" + isFC + " | Score： " + strconv.Itoa(PhigrosB19Data[i].Score) + " | ACC: " + strconv.FormatFloat(PhigrosB19Data[i].Acc, 'f', 3, 64) + " | RKS: " + strconv.FormatFloat(PhigrosB19Data[i].Rks, 'f', 2, 64) + " < " + strconv.FormatFloat(PhigrosB19Data[i].Rating, 'f', 2, 64) + "\n"
		}
		last := "\nGenerated By Lucy | Phigros Library Project | Generate Code Beta Version 0.1 | GameVersion: " + strconv.Itoa(PhigrosSaves.GameVersion)
		formatText := header + renderText + last
		base64Font, err := text.RenderToBase64(formatText, text.BoldFontFile, 1920, 45)
		if err != nil {
			ctx.SendChain(message.Reply(ctx.Event.MessageID), message.Text("ERR: ", err))
			return
		}
		ctx.SendChain(message.Image("base64://" + binary.BytesToString(base64Font)))
	})
}
